--- 
# TinyTapeout project information
project:
  wokwi_id:    0        # If using wokwi, set this to your project's ID

# If using an HDL, set wokwi_id as 0 and uncomment and list your source files here. 
# Source files must be in ./src and you must list each source file separately
  source_files:        
    - accumulator_microcontroller.v
    - alu.v
    - control_unit.v
    - memory_bank.v
    - shift_register.v
    - kiwih_tt_top.v
  
  top_module:  "kiwih_tt_top"      # put the name of your top module here, make it unique by prepending your github username

# Keep a track of the submission yaml
yaml_version: 3.0

# As everyone will have access to all designs, try to make it easy for someone new to your design to know what
# it does and how to operate it. This info will be automatically collected and used to make a datasheet for the chip.
#
# Here is a great example: https://github.com/davidsiaw/tt02-davidsiaw-stackcalc/blob/38c5647f83aad2aec675d566aa3d67b98f0aac81/info.yaml
documentation: 
  author:       "Hammond Pearce"
  title:        "QTCore-A1"
  language:     "Verilog"
  description:  "An accumulator-based 8-bit microarchitecture designed via a GPT-4 conversation."

# Longer description of how the project works. You can use standard markdown format.
  how_it_works: |
      The QTCore-A1 is a basic accumulator-based 8-bit microarchitecture (with an emphasis on the micro). It is a Von Neumann design (shared data and instruction memory).
      
      Although primarily designed for Tiny Tapeout 3, it is parameterized and may be synthesized to FPGAs (and a project file for CMOD A7 is provided on the project GitHub).

      Probably the most interesting thing about this design is that all functional Verilog beyond the Tiny Tapeout wrapper was written by GPT-4, i.e. not a human! 
      The author (Hammond Pearce) developed with GPT-4 first the ISA, then the processor, fully conversationally. Hammond wrote the test-benches to validate the design, and then had the
      appropriate back-and-forth with GPT-4 to have it fix all bugs.
      For your interest, we will provide all conversation logs in the project repository.

      The architecture defines a processor with the following components:
      - Control Unit: 2-cycle FSM for driving the processor (3 bit one-hot encoded state register)
      - Program Counter: 5-bit register containing the current address of the program
      - Instruction Register: 8-bit register containing the current instruction to execute
      - Accumulator: 8-bit register used for data storage, manipulation, and logic
      - Memory Bank: 17 8-bit registers which store instructions and data. The 17th register is used for I/O.

      In order to interact with the processor, all registers are connected via one large scan chain.
      As such, you can use an external microcontroller's SPI peripheral to read and write the status of the processor.
      We use the SPI clock SPI_SCK as the clock to drive both the QTCore-A1 and the scan chain.
      You choose which you are using by asserting the appropriate chip select.
      This makes it quite easy to interact with the processor.

      The ISA description follows. 
      For your convenience, we also provide an assembler in Python (also written by GPT-4) which makes it quite easy to write simple programs.

      ### Immediate Data Manipulation Instructions
      - ADDI: Add 4-bit Immediate to Accumulator
        - Opcode (4 bits): 1110
        - Immediate (4 bits): 4-bit Immediate
        - Register Effects: ACC <- ACC + IMM

      ### Instructions with Variable-Data Operands
      - LDA: Load Accumulator with memory contents
        - Opcode (3 bits): 000
        - Operand (5 bits): Memory Address
        - Register Effects: ACC <- M[Address]

      - STA: Store Accumulator to memory
        - Opcode (3 bits): 001
        - Operand (5 bits): Memory Address
        - Register Effects: M[Address] <- ACC

      - ADD: Add memory contents to Accumulator
        - Opcode (3 bits): 010
        - Operand (5 bits): Memory Address
        - Register Effects: ACC <- ACC + M[Address]

      - SUB: Subtract memory contents from Accumulator
        - Opcode (3 bits): 011
        - Operand (5 bits): Memory Address
        - Register Effects: ACC <- ACC - M[Address]

      - AND: AND memory contents with Accumulator
        - Opcode (3 bits): 100
        - Operand (5 bits): Memory Address
        - Register Effects: ACC <- ACC & M[Address]

      - OR: OR memory contents with Accumulator
        - Opcode (3 bits): 101
        - Operand (5 bits): Memory Address
        - Register Effects: ACC <- ACC | M[Address]

      - XOR: XOR memory contents with Accumulator
        - Opcode (3 bits): 110
        - Operand (5 bits): Memory Address
        - Register Effects: ACC <- ACC ^ M[Address]

      ### Control and Branching Instructions
      - JMP: Jump to memory address
        - Opcode (8 bits): 11110000
        - PC Behavior: PC <- ACC (Load the PC with the address stored in the accumulator)

      - JSR: Jump to Subroutine (save address to ACC)
        - Opcode (8 bits): 11110001
        - PC Behavior: ACC <- PC + 1, PC <- ACC (Save the next address in ACC, then jump to the address in ACC)

      - BEQ_FWD: Branch if equal, forward (branch if ACC == 0)
        - Opcode (8 bits): 11110010
        - PC Behavior: If ACC == 0, then PC <- PC + 3 (Jump 2 instructions forward if ACC is zero)

      - BEQ_BWD: Branch if equal, backward (branch if ACC == 0)
        - Opcode (8 bits): 11110011
        - PC Behavior: If ACC == 0, then PC <- PC - 2 (Jump 1 instruction backward if ACC is zero)

      - BNE_FWD: Branch if not equal, forward (branch if ACC != 0)
        - Opcode (8 bits): 11110100
        - PC Behavior: If ACC != 0, then PC <- PC + 3 (Jump 2 instructions forward if ACC is non-zero)

      - BNE_BWD: Branch if not equal, backward (branch if ACC != 0)
        - Opcode (8 bits): 11110101
        - PC Behavior: If ACC != 0, then PC <- PC - 2 (Jump 1 instruction backward if ACC is non-zero)

      - HLT: Halt the processor until reset
        - Opcode (8 bits): 11111111
        - PC Behavior: Stop execution (PC does not change until a reset occurs)

      ### Data Manipulation Instructions
      - SHL: Shift Accumulator left
        - Opcode (8 bits): 11110110
        - Register Effects: ACC <- ACC << 1

      - SHR: Shift Accumulator right
        - Opcode (8 bits): 11110111
        - Register Effects: ACC <- ACC >> 1

      - SHL4: Shift Accumulator left by 4 bits
        - Opcode (8 bits): 11111000
        - Register Effects: ACC <- ACC << 4

      - ROL: Rotate Accumulator left
        - Opcode (8 bits): 11111001
        - Register Effects: ACC <- (ACC << 1) OR (ACC >> 7)

      - ROR: Rotate Accumulator right
        - Opcode (8 bits): 11111010
        - Register Effects: ACC <- (ACC >> 1) OR (ACC << 7)

      - LDAR: Load Accumulator via indirect memory access (ACC as ptr)
        - Opcode (8 bits): 11111011
        - Register Effects: ACC <- M[ACC]

      - DEC: Decrement Accumulator
        - Opcode (8 bits): 11111100
        - Register Effects: ACC <- ACC - 1

      - CLR: Clear (Zero) Accumulator
        - Opcode (8 bits): 11111101
        - Register Effects: ACC <- 0

      - INV: Invert (NOT) Accumulator
        - Opcode (8 bits): 11111110
        - Register Effects: ACC <- ~ACC

      ## Example programming using the assembler

      Writing assembly programs for QTCore-A1 is simplified by the assembler produced by GPT-4. First, we define two additional meta-instructions:
      
      ### Meta-instructions:

      - NOP: Do nothing
        - Implemented as ADDI 0

      - DATA: Define raw data to be loaded at the current address
        - Operand (8 bits): 8-bit data value

      ### Presenting programs to the assembler:
      
      1. Programs are presented in the format `[address]: [mnemonic] [optional operand]`
      2. There is a special meta-instruction called DATA, which is followed by a number. If this is used, just place that number at that address.
      3. Programs cannot exceed the size of the memory (in Tiny Tapeout 3, this is 17 bytes including the IO register).
      4. The memory contains both instructions and data.

      ### Example program:
      An interesting example program is presented. This assumes a button is connected to the general purpose input, and some LEDs are connected to the LED output.

      We assume this file is called `test_btn_led.asm`:
      ```
      ; This program tests the btn and LEDs
      ; It will wait for low->high transitions on the button input. 
      ; After receiving this, it will toggle a set of LEDs.
      ;
      ; BTNs and LEDS are at address 17, btn at LSB
      0: LDA 17 ; load the btn and LEDS
      1: AND 16 ; mask the btn
      2: BNE_BWD ; if btn&1 is not zero then branch back to 0
      3: LDA 17 ; load the btn and LEDS
      4: AND 16 ; mask the btn
      5: BEQ_BWD ; if btn&1 is zero then branch back to 3
      ;
      ; the button has now done a transition from low to high
      ;
      6: LDA 14 ; load the counter toggle
      7: XOR 16 ; toggle the counter using the btn mask
      8: STA 14 ; store the counter value
      9: ADDI 14 ; get the counter value offset (if 0, will be 14 (which is 0), if 1, 15)
      10: LDAR ; load the counter LED pattern
      11: STA 17 ; store the LED pattern
      12: CLR
      13: JMP
      ;
      ; data
      ;
      14: DATA 0; toggle and LED pattern 0
      15: DATA 24; LED pattern of ON (test for led_out=value 12, since 24>>1 == 12)
      16: DATA 1 ; btn and counter mask
      ```
      
      To compile this program, we would invoke the assembler as follows:
      
      ```
      $ ./assembler.py test_btn_led.asm
      ```

      The assembler will generate the following files for us:
      - `test_btn_led.bin`: This is a binary representation of the assembly program. It can be used, or we can use one of the helper formats...
      - `test_btn_led.memarray.v`: This provides the binary ready for use in a Verilog test bench to directly write to the memory of the processor.
      - `test_btn_led.scanchain.v`: This provides the binary ready for use in the provided Verilog test bench which loads and unloads programs via the scan chain.
      - `test_btn_led.c`: This provides the binary as an array suitable for use in a C program on an external microcontroller which can load it into the processor via SPI.

      ### Processor operation

      The processor executes all instructions via 2 stages (multi-cycle).
      
      The timing is as follows. Note the branch instructions are +2/-3 due to the already-incremented PC in the fetch stage.

      **FETCH cycle (all instructions)**

      1. IR <- M[PC]
      2. PC <- PC + 1

      **EXECUTE cycle**

      For **Immediate Data Manipulation Instructions**:

      * ADDI: ACC <- ACC + IMM

      For **Instructions with Variable-Data Operands**:

      * LDA: ACC <- M[Address]
      * STA: M[Address] <- ACC
      * ADD: ACC <- ACC + M[Address]
      * SUB: ACC <- ACC - M[Address]
      * AND: ACC <- ACC & M[Address]
      * OR:  ACC <- ACC | M[Address]
      * XOR: ACC <- ACC ^ M[Address]

      For **Control and Branching Instructions**:

      * JMP: PC <- ACC
      * JSR: ACC <- PC, PC <- ACC
      * BEQ_FWD: If ACC == 0, then PC <- PC + 2
      * BEQ_BWD: If ACC == 0, then PC <- PC - 3
      * BNE_FWD: If ACC != 0, then PC <- PC + 2
      * BNE_BWD: If ACC != 0, then PC <- PC - 3
      * HLT: (No operation, processor halted)

      For **Data Manipulation Instructions**:

      * SHL: ACC <- ACC << 1
      * SHR: ACC <- ACC >> 1
      * SHL4: ACC <- ACC << 4
      * ROL: ACC <- (ACC << 1) OR (ACC >> 7)
      * ROR: ACC <- (ACC >> 1) OR (ACC << 7)
      * LDAR: ACC <- M[ACC]
      * DEC: ACC <- ACC - 1
      * CLR: ACC <- 0
      * INV: ACC <- ~ACC


# Instructions on how someone could test your project, include things like what buttons do what and how to set the clock if needed
  how_to_test:  |
      TODO: Please see the project specification.

# A description of what the inputs do
  inputs:               
    - clock - connect to an SPI SCK.
    - reset (active high)
    - scan enable (active low) - connect to an SPI chip select.
    - processor enable (active low) - connect to an SPI chip select.
    - scan data in - connect to an SPI MOSI.
    - general purpose input (e.g. Button). This input will be provided to the I/O register bit 0.
    - none
    - none
# A description of what the outputs do
  outputs:
    - general purpose output 0 (e.g. LED segment a). This output comes from the I/O register bit 1.
    - general purpose output 1 (e.g. LED segment b). This output comes from the I/O register bit 2.
    - general purpose output 2 (e.g. LED segment c). This output comes from the I/O register bit 3.
    - general purpose output 3 (e.g. LED segment d). This output comes from the I/O register bit 4.
    - general purpose output 4 (e.g. LED segment e). This output comes from the I/O register bit 5.
    - general purpose output 5 (e.g. LED segment f). This output comes from the I/O register bit 6.
    - general purpose output 6 (e.g. LED segment g). This output comes from the I/O register bit 7.
    - scan data out - connect to an SPI MISO.

# The following fields are optional
  tag:          "processor, test"      # comma separated list of tags: test encryption, experiment, clock, animation, utility, industrial, pwm, fpga, alu, microprocessor, risc, riscv, sensor, signal generator, fft, filter, music, bcd, sound, serial, timer, random number generator, calculator, decoder, counter, puzzle, multiplier, game, oscillator,
  external_hw:  "spi"      # Describe any external hardware needed
  discord:      "HammondP#2054"      # Your discord handle, used for communication and automatically assigning tapeout role after a submission
  doc_link:     ""      # URL to longer form documentation, eg the README.md in your repository
  clock_hz:     10000       # Clock frequency in Hz (if required)
  picture:      ""      # relative path to a picture in your repository
